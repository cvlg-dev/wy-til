


# 1. 운영체제 개요

## 1.1. 컴퓨터 시스템의 구성

### 1.1.1. 컴퓨터의 구성요소

- 하드웨어
	- CPU, 메모리, 저장장치, 입출력장치, 네트워크 장치
- 소프트웨어
	- 응용소프트웨어, 시스템 소프트웨어
- 펌웨어	

운영체제는 시스템 소프트웨어에 속한다.

## 1.2. 컴퓨터 시스템과 운영체제

### 1.2.1. 운영체제

- 컴퓨터의 하드웨어 자원을 관리
- 컴퓨터 프로그램이 동작하기 위한 서비스를 제공하는 시스템

### 1.2.2. 운영체제가 없던 컴퓨터 시스템

- 개발자는 하드웨어 제어 방법을 잘 알아야 함.
- 여러 응용프로그램이 하드웨어를 공유하는 경우 자원 분할이 어려움

### 1.2.3. 운영체제의 역할

1. 컴퓨터 시스템의 운영
	- 컴퓨터 시스템의 자원(메모리, 저장공간)을 효율적으로 제어 및 관리
	- 응용프로그램들의 실행을 도와주는 소프트웨어
2. 사용자 지원
	- 사용자의 명령을 해석하여 실행
	- 사용자와 하드웨어 사이의 중간 매개체 역할 수행

- 하드웨어에 대한 제어는 운영체제만 함.
- 응용프로그램은 운영체제를 통해서만 하드뒈어를 이용함.
- 따라서 응용프로그램 개발자들은 운영체제를 감안하여 개발을 수행하면 됨.

### 1.2.4. 운영체제와 CPU 의 동작 모드

운영체제는 응용프로그램이 직접 하드웨어에 접근하는 것알 방지해야하기 때문에, 두가지 모드를 통해 시스템을 운영함.

1. 슈퍼바이저 모드 (커널 모드) : 운영체제의 커널이 동작되는 모드
	- 운영체제의 커널이 동작되는 모드
	- 하드웨어를 직접 제어할 수 있는 CPU명령어 사용가능
2. 보호모드 (사용자 모드)
	- 응용프로그램이 동작되는 모드
	- 하드웨어를 직접 제어할 수 있는 CPU 명령어 사용이 불가능
	- 시스템호출
		- 하드웨어에 대한 제어가 필요한 경우에는 운영체제에 요청, 슈퍼바이저 모드로 변경이 되고, 커널이 동작하여 하드웨어를 제어함.


**커널이란?  (위키피디아)**
>컴퓨터의 운영 체제의 핵심이 되는 컴퓨터 프로그램의 하나로, 시스템의 모든 것을 완전히 통제함. 
>
>다음과 같은 역할을 함.
> 
>- 보안
>- 자원관리
>- 추상화

- 커널의 대표적 구성방식
	- 일체형 커널(monolothic kernel)
		- 운영체제의 모든 서비스가 커널 내에 포함도미
		- 장점: 커널 내부 요소들이 서로 효율적으로 상호작용할 수 있음.
		- 단점: 한 요소에 있는 오류로 인해 시스템 전체에 장애가 발생할 수 있음.
		- 예시: UNIX, Linux 운영체제들
	- 마이크로 커널(micro kernel)
		- 운영체제의 대부분의 요소들을 커널 외부로 분리
		- 커널 내에는 메모리관리, 멀티태스킹, 프로세스 간 통신(IPC) 등 최소한의 요소들만 남김
		- 장점: 새로운 서비스를 추가하여 운영체제를 확장하기 쉽고, 유지보수가 용이하며 안정성이 우수함
		- 단점: 외부요소들 사이에는 IPC를 통해야만 하므로 성능 저하가 발생함


# 2. 운영체제의 구성

컴퓨터 시스템의 자원의 성격에 따라 구분함.

## 2.1. 프로세스 관리자

- 프로세스를 생성, 삭제, CPU할당을 위한 스케줄을 결정.
- 각 프로세스의 상태를 관리하며 상태 전이를 처리

## 2.2. 메모리 관리자

- 메모리 공간에 대한 요구의 유효성을 체크
- 메모리 할당 및 회수
- 메모리 공간을 보호

## 2.3. 장치 관리자

- 컴퓨터 시스템의 모든 장치를 관리
	- 디스플레이, 키보드, 프린터, 디스크 드라이브, 네트워크 장치 등등
- 시스템의 장치를 할당, 작동 시작, 반환

## 2.4. 파일 관리자

- 컴퓨터 시스템의 모든 파일을 관리
- 파일의 접근 제한 관리
- 파일을 열어 자원을 할당하거나 파일을 닫아 자원을 회수



# 3. 운영체제의 유형

운영체제의 유형은 응답시간의 속도, 데이터 입력의 방식에 따라 분류됨.

- 일괄처리 운영체제 (batch processing)
	- 작업을 모아서 처리
	- 사용자와 상호작용 없이 순차적으로 모아서 배치로 실행
	- 작업이 끝날 때까지는 사용자가 개입할 수 없음.
	- 효율성 평가: 처리량, 반환시간
		- 처리량: 주어진 시간 안에 처리된 작업의 수
		- 반환시간: 작업의 생성 시점부터 종료 시점까지의 소요시간
- 대화형 운영체제 (interactive)
	- 시분할 운영체제라고도 함
	- 일괄처리 운영체제보다 빠르지만 실시간 운영체제보다는 느린 응답시간
	- 이용자에게 즉각적인 피드백을 제공함.
	- 효율성 평가: 응답시간
		- 응답시간: 요청한 시점부터 반응이 시작되는 시점까지의 소요시간
- 실시간 운영체제(real-time: RTOS)
	- 가장 빠른 응답시간
	- 처리의 결과가 현재의 결정에 영향을 주는 환경에서 사용함.
	- 범용보다는 특수한 용도로 적용되는 경우가 많음
		- 사용 예: 우주선 비행시스템, 미사일 제어, 증권거래관리 시스템, 은행 입출금 시스템 등에 사용됨.
- 하이브리드 운영체제(hybrid)
	- 일괄처리OS와 대화형OS의 결합
	- 이용자는 터미널을 통해 접속하고 빠른 응답시간을 얻음
	- 대화형 작업이 만힞 않을 경우 백그라운드에서 배치 프로그램 실행
	- 혀냊 사용되고 있는 대부분의 대형 컴퓨터 시스템은 하이브리드 운영체제.



# 4. 운영체제의 역사

## 1940 ~ 1950

### 1940년대: 초기 전자식 디지털 컴퓨터

- 운영체제가 존재하지 않음
- 기계적 스위치에 의해 작동됨.

### 1950년대: 단순 순차처리 및 단일흐름 일괄처리

- 한번에 오직 하나의 작업만을 수행
- 최초의 운영체제 등장 (IBM 701)

## 1960~1970

### 1960년대: 멀티프로그래밍

- 몇 개의 작업이 메모리에 동시에 있게 하는 멀티프로그래밍 등장
- 동시적인 대화식 사용자의 멀티프로그래밍을 위한 시분할(timesharing systme) 처리 개념 등장
- 다중 대화식 사용자 지원(multiple interactive users)

### 1970년대: 멀티모드 시분할

- 일괄처리, 시분할 처리, 실시간 처리를 지원하는 멀티모드 시분할의 보편화
- 근거리 지역 네트워크(LAN)의 실용화
- 정보보호 및 보안문제의 증대로 암호화의 중요성 대두

## 1980~1990

### 1980년대: 분산 네트워크

- 운영체제 기능이 하드웨어 자체에 포함된 펌웨어 개념이 대두됨.
- 2개 이상의 프로세서를 이용하는 멀티프로세서 환경
- 네트워크의 대두와 함께 클라이언트/서버 모델이 확산됨.


### 1990년대: 병렬처리 및 분산처리

- 순차처리를 벗어나 분산 및 병렬처리 발전
- GUI가 강화됨
- 선점형 멀티태스킹, 멀티쓰레딩, 가상 메모리가 보편화 됨.


## 2000 ~

### 2000년대 이후: 모바일 및 임베디드 OS

- 시스템은 고속화, 고기능화, 경량화 방향으로 발전
- 다양한 통신망의 확대와 갭아형 시스템의 발달
- 기능지원, 호환성 극대화, 확장성, 사용자 편의성을 높임
- 네트워크 기반의 분산 및 병렬 운영체제 보편화
- 클라우드 환경의 운여체제
- 64비트CPU에 호환되는 64비트용 운영체제
- 모바일 장치 대중화로 모바일 운영체제 보편화
- 가전제품을 위한 임베디드 운영체제 보편화


## 2000년대 이후의 주요 운영체제

- 중형컴퓨터: UNIX, Linux
- 소형 컴퓨터: Windows, MacOS
- 임베디드: Embedded Linux, pSOS, VRTX
- 모바일: iOS, Android ... 



