# 2. 알고리즘 기초



## 2.1 알고리즘의 개념

> 주어진 문제를 풀기 위한 명령어들의 단계적 나열

### 2.1.1. 컴퓨터로 문제를 풀기 위한 조건

- 입출력: 0개 이상의 외부 입력 --> 1개 이상의 출력
- 명확성: 각 명령은 모호하지 않고 단순 명확해야 함
- 유한성: 한정된 수의 단계를 거친 후에는 반드시 종료
- 유효성: 모든 명령은 컴퓨터에서 수행 가능해야 함
- (+) 실용적 관점 : 그리고 효율적이어야 함

### 2.1.2. 알고리즘 생성 단계

1. 설계
2. 표현/기술
3. 정확성 검증
4. 효율성 분석


## 2.2. 알고리즘의 설계 

- 주어지는 문제는 속성과 조건등이 매우 다양함.
- 그래서 범용적인 설계 기법이란 존재하지 않음.

그러나,

대표적인 알고리즘 설계 기법이 존재함


1. 분할정복 방법 divide conquer
2.  동적 프로그래밍 dynamic programming
3. 욕심쟁이 방법 greedy algorithm


## 2.3. 알고리즘의 분석

- 정확성 분석
	- 수학적 기법을 사용해서 하는 이론적인 증명
		- 유효한 입력이 발생하는지
		- 유한한 시간 내 실행되는지
		- 의도한 정확한 결과가 생성되는지

		
- 효율성 분석
	- 알고리즘 수행에 필요한 컴퓨터 자원의 양을 측정함
	- 메모리의 양 : 공간 복잡도
		- 정적 공간 + 동적 공간
	- 수행시간 : 시간 복잡도


### 2.3.1. 시간 복잡도

- 측정 방법
	- (X) 구현한 알고리즘을 실행시켜서 실제 수행시간 측정
		- 일반성이 결여됨.
			- 컴퓨터 속도
			- 언어
			- 컴파일러의 종류 등
	- (O) 알고리즘의 단위 연산이 수행되는 횟수의 합

	
	
- 시간복잡도에 영향을 미치는 요인
	- 입력의 크기  (n)
		- **시간복잡도는 입력 크기 n에 대한 함수 f(n)으로 표현함**
		- 입력으로 제공되는 데이터의 크기
		- 문제가 해결하려는 대상이 되는 개체의 개수 
		- 입력 크기 n이 증가하면 수행 시간도 증가함
	- 입력 데이터의 상태
		-  시간복잡도는 입력 데이터의 상태에 종속적
		-  종류
			- 평균 수행 시간
			- 최선 수행 시간
			- **최악 수행 시간 (o)**
				- 알고리즘 수행시간이 더 이상 나빠질 수 없는
				- 수행시간의 상한 (upper bound) 을 기준으로 둠




## 2.4. 점근성능

>입력 크기  n이 무한대로 커짐에 따라 결정되는 성능

### 2.4.1.  점근성능의 결정 방법

- 수행시간의 다항식 함수에서 **최고차항만을 취해서 표현함**
- 수행 시간의 정확한 값이 아닌 어림값
	- 단, 수행 시간의 증가 추세를 파악하는데 용이함.
	- 알고리즘을 비교할 때, 우열함을 파악하고 표현하는데 용이함.

### 2.4.2. 점근 성능의 표기법

1. Big-O
	- 점근적 상한
	- 아무리 나빠도 최악의 수행보다 같거나 작음을 의미
2. Big-Omega
	- 점근적 하한
3. Big-theta
	- 점근적 상하한

	
### 2.4.3. Big-O 표기간의 연산 시간과 크기 관계

![](https://github.com/cvlg-dev/wy-til/tree/main/knou/2021-01-algorithm/source/02-01.png)


상수시간 `O(1)` < 로그 시간 `O(log2 n)` < 선형 시간 `O(n)` < 로그 선형 시간 `O(n log2 n)` < 제곱 시간 `O(n^2)` < 3제곱 시간 `O(n^3)` <  지수 시간 `O(2^n)`



## 2.5. 순환 알고리즘의 성능

>알고리즘 수행 과정에서 자기 자신의 알고리즘을 다시 수행하는 형태

- 점화식으로 표현
	- 예) `T(n) = T(n/2) + O(1), T(1)=C_1`
- 점화식을 풀어서 시간복잡도를 낼 수 있다

주요한 점화식 예시
- 퀵 정렬의 최악의 수행시간
- 이진 탐색의 수행시간
- 합병 정렬의 수행시간
- 퀵 정렬의 최선의 수행시간
