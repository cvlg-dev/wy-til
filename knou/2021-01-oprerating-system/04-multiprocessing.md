# 1. 병행 프로세스 개념

## 1.1. 병행성(concurrency)

- 여러 개의 프로세스 또는 쓰레드가 동시에 실행되는 시스템의 특성
- 쓰레드: 프로세스 내에서 실행되는 세부 작업의 단위



## 1.2. 병행 프로세스의 실행 형태

### 1.2.1. CPU의 개수에 따른 병행 프로세스

- CPU가 1개인 경우.

  - 하나의 CPU에서 인터리빙 형식으로 실행됨

  - 인터리빙(interleaving) 
    - CPU를 잘게 쪼개서 복수개의 프로세스 반복 실행

- CPU가 2개 이상인 경우
  - 프로세스마다 하나의 CPU를 배당

### 1.2.2. 메모리 구조에 따른 병행 프로세스

- 강결합 멀티프로세서 시스템
  - 공유 메모리 구조
    - 하나의 메모리를 여러 개의 CPU가 공유
- 약결합 멀티프로세서 시스템
  - 분산 메모리 구조
    - CPU마다 메모리가 있음
    - 여러 컴퓨터를 네트워크로 묶음



## 1.3. 병행성 문제

### 1.3.1. 병행 프로세스들의 상호작용 문제

- 공유자원 점유문제
  - 특정 자원을 여러 프로세스가 공유
- 동기화 문제
  - 프로세스 사이의 순서관계를 정하는 문제
- 통신 문제
  - 어떻게 컴퓨터 사이에 통신하여 데이터를 주고 받는 것인지

### 1.3.2. 상황에 따른 구분

- 단일 프로세스 내의 병행성
- 프로세스 간의 병행성



## 1.4. 단일 프로세스 내 병행성

### 1.4.1. 우선순위 그래프

- 정점 & 간선이 존재
- DAG의 형태
  - 방향이 있는 간선
  - 사이클이 없는 그래프
- 우선순위 순서에 따라서 간선을 연결

### 1.4.2. Fork/Join 구조

- fork L: 2개의 병행 수행을 만듦 (병행성을 만듬)
  - L1과 L2로 나뉘어진 프로세스가 별도로 작동함.
- join n: 병행하는 n개의 것들을 하나로 묶어줌

### 1.4.3. 병행문

- I개의 프로세스가 여러 가닥의 병렬 프로세스로 분할되었다가 다시 하나로 결합됨

- parallel begin/end

  - parbegin, parend 사이에 존재하는 프로세스는 병행으로 작동하고, parend 이후 하나로 합쳐짐

  ```
  S_0;
  parbegin
  	S_1;
  	S_2;
  	S_3;
  	S_4;
  	S_5;
  	...
  	S_n;
  parend
  S_n+1
  ```

## 1.5. 프로세스 간의 병행성

- 독립적인 프로세스
- 비동기 병행 프로세스

### 1.5.1. 비동기 병행 프로세스

- 유기적인 프로세스로 자원을 공유하는 경우
- 공유자원을 사용하면 양쪽에서 작업하기 때문에 데이터가 동기화 되지 못 하는 문제가 발생함.

# 2. 동기화 & 임계영역

## 2.1. 프로세스 동기화 & 임계영역

### 2.1.1. 프로세스 동기화 (synchronization)

- 2개 이상의 프로세스에 대한 처리 순서를 결정하는 것.
  - 동시에 사용할 수 없는 공유자원이 엮인 경우
  - 한 프로세스의 처리 결과에 따라 다른 프로세스의 처리가 영향을 받는 경우

### 2.1.2. 임계영역 (critical section)

- 2개 이상의 프로세스가 동시에 액세스 하면 안 되는 공유자원을 액세스 하는 코드 영역
- **임계자원: 2개 이상의 프로세스가 동시에 액세스 하면 안 되는 공유자원***
  - 진입영역(entry section): 임계영역 진입을 요청하고 여부를 결정하는 영역
  - 해제영역(exit section): 임계영역의 수행을 마치고 다음 진입할 프로세스를 선택하는 영역
  - 잔류영역(remainder section): 그 이외 나머지 영역

## 2.2. 임계영역 문제 해결을 위한 요구 조건

### 2.2.1. 상호배제

- 한 프로세스가 임계 영역에서 실행 중일 때, 다른 어떤 프로세스도 임계영역에서 실행될 수 없음
- 2개 이상의 프로세스가 동시에 임계영역에 진입하지 못 하도록 하는 것
- 겹치지 않고 별도로 처리되도록 함

### 2.2.2. 진행

- 임계영역에서 실행 중인 프로세스가 없고, 여러 프로세스가 임계영역에 진입하고자 할 때,
  - 적절히 한 프로세스를 결정해야 하며, 이 결정을 무한정 미룰 수 없음. 진행되어야 함.

### 2.2.3. 제한된 대기

- 한 프로세스가 임계영역 진입 요청을 한 후 수락될 때까지,
  - 다른 프로세스가 임계영역 진입을 허가 받는 횟수는 제한이 있어야 함.

## 2.3. 임계영역 문제 해결을 위한 도구

- Test-and-Set (TS)
- 세마포어 (Semaphore)

### 2.3.1. Test-and-Set

- 상호배제의 하드웨어적 해결 방법이며, 분리가 불가능한 단일 기계 명령어임
- 동작 방식
  - lock 을 설정함.
  - 프로세스 P가 절대영역에서 수행 가능하다면 조건 코드는 0(free) 에서 1(busy)로 바뀜
    - 프로세스 P의 수행이 종료되면 조건 코드는 0(free)로 다시 reset되면서 다른 프로세스가 들어갈 수 있게 함.
  - 이미 다른 프로세스가 절대영역에서 수행중이라면, 프로세스 P는 조건 코드를 계속 검사하며 절대 영역에 들어갈 수 있을 때까지 대기 루프에 머무르게 됨.
- 문제점
  - 많은 프로세스가 임계영역에 들어가기를 원할 때, 기아가 발생할 수 있음
    - 기아: 프로세스가 필요한 자원할당을 받지 못하고 계속적으로 대기하게 되는 상황
  - Busy waiting을 함으로서 다른 작업이 사용할 수 있는 CPU 사이클을 낭비함

### 2.3.2. 세마포어

- 다익스트라(Dijkstra)가 제안한 동기화 도구

- 세마포어 `s`: 사용 가능한 자원의 수 또는 잠김/열림 등의 상태를 나타내는 값을 저장하는 정수형 공용 변수

- 세마포어 `s` 는 두 표준단위 연산 `P`와 `V`에 의해서만 접근됨

  - P(s): 검사, 검사시키는 시도

    ```pseudocode
    if (s > 0) then
        s := s-1;
    else
        현재의 프로세스를 대기;
    ```

  - V(s): 증가

    ```pseudocode
    if (1개 이상의 프로세스가 대시중) then
        (그 중 1개의 프로세스만 진행);
    else
        s := s+1
    ```

- 동작 방식

  ```pseudocode
  repeat
      P(mutex);   # mutex=1 설정
      임계영역
      V(mutex);
      잔류영역
  until false;
  ```



- 동기화 문제 해결
  -  Block / wakeup 프로토콜을 통해 동기화 문제를 해결함
     -  프로세스A가 입출력을 요구하면 입출력이 끝날 때까지 프로세스A는 블록 상태가 됨.
     -  다른 프로세스가 프로세스A의 블록상태를 깨워야 함.



# 3. 프로세스의 상호협력

공통작업을 수행하기 위해 서로 협력하는 경우

## 3.1. 생산자 / 소비자 문제

> 생산자 -> | 버퍼 | -> 소비자

- 생산자: 
  - 버퍼에 데이터를 채우는 프로세스
  - 버퍼가 가득 차 있다면 생산자는 대기해야 함
- 소비자: 
  - 버퍼에 있는 데이터를 읽어내는 프로세스
  - 버퍼가 비어있다면 소비자는 대기해야 함
- 버퍼에 데이터를 쓰고 읽는 과정 사이에는 상호배제와 동기화가 필요하며, 세마포어를 이용하여 구현함.
  - 상호배제: 한 순간에 한 프로세스만이 버퍼를 사용해야 하므로
  - 동기화: 생산이 이루어져야만 소비가 가능하므로

### 3.1.1. 세마포어 사용

- mutex 초기값은 1
- full의 초기값은 0
- empty의 초기값은 n

```
# 생산자 프로세스

repeat
    nextp에 데이터 항목을 생산 --- (1)
    P(empty)
    P(mutex)
    nextp를 버퍼에 넣음 --- (3)
		V(mutex)
		V(full)
until false;
```

```
# 소비자 프로세스

repeat
		P(full)
		P(mutex)
		버퍼에서 데이터 항목을 꺼내 nextc에 넣음 --- (2)
		V(mutex)
		V(empty)
		nextc를 소비 --- (4)
		
until false;
```





## 3.2. 판독기 / 기록기 문제

데이터를 공유할 때 생기는 병행 프로세스 문제. 복수의 판독기, 기록기가 동시에 접근하면, 병행성 조건을 침해하는 문제가 발생

- 데이터 공유객체를 읽거나 쓰기(갱신)할 때, 
  - 판독기: 읽고자 하는 프로세스
  - 기록기: 쓰고자 하는 프로세스

다음은 우선순위 문제

### 제 1 판독기/기록기 문제 (판독기 우선)

- 기록기가 이미 공유객체의 사용을 허가 받은 것이 아니라면, 판독기는 대기하지 않음
  - 기록기의 기아상태 유발 가능
- 세마포어를 이용한 문제 접근

### 제 2 판독기/기록기 문제

- 일단 기록기가 준비되었다면 기록을 가능한 한 빨리 수행할 수 있도록 함.
  - 판독기의 기아상태 유발 가능
- 세마포어를 이용한 문제 접근

# 4. 프로세스 간의 통신

IPC - InterProcess Communication

- 병행 프로세스 사이의 통신을 위한 방법
  - 공유기억장치 기법
  - 메시지 시스템 기법

- 두 방법은 상호 배타적이 아님
  - 단일 운영체제에서 동시에 사용 가능함

## 4.1. 공유기억장치 기법 (shared memory)

- 프로세스 간에 공유 변수를 이용하여 정보를 교환함
- 고속으로 통신할 수 있음
- 운영체제는 단지 공유 기억장소만 제공함. 커널은 전혀 관여하지 않음.
  - 통신기능의 책임은 응용프로그래머에게 있음



## 4.2. 메시지 시스템 (message system)

- 메시지를 교환하는 방식으로 정보를 교환함
- 통신 기능 제공의 책임이 운영체제에 있음.
- send / receive 연산자
  - send와 receive 연산자는 커널을 통해서 주고받게 됨
- 소량의 데이터 교환에 유용함



**통신링크**

- 프로세스들 사이에 메세지를 주고 받기 위한 연결 통로
- 논리적 구현에 대한 이슈
  - 링크를 어떻게 설정하는지?
  - 한 링크가 2개 이상의 프로세스와 연결 가능한지?
  - 통신 프로세스의 쌍 사이에 얼마나 많은 링크가 있는지?
  - 링크의 용량은? 어느정도 버퍼공간을 갖는지?
  - 메세지의 크기는 어느 정도인지? 메세지는 가변/고정크기 크기인지?
  - 링크가 단방향 또는 양방향인지?



### 4.2.1. 직접통신

- 메시지 전달 연산에 수신자나 송신자 이름을 명시함
- 성질
  - 통신을 원하는 쌍 사이에 링크가 자동적으로 설정됨
    - 서로 상대방의 신원(identity)을 알아야 함
  - 하나의 링크는 두 프로세스 사이만 연관됨
  - 프로세스 쌍 사이에는 정확히 하나의 링크가 존재함
  - 링크는 양방향
- 유형
  - 대칭형: 전송자와 수신자는 모두 통신을 하기 위해 상대방을 명명
  - 비대칭형: 전송자만 수신자를 명명함

### 4.2.2. 간접통신

- 우편함이란 것을 사용함.
  - 프로세스에 의해 메세지가 넣고 빠지는 객체로 취급함
  - 우편함은 유일한 이름을 가짐
  - 서로 다른 우편함에 의하여 다른 프로세스와 통신 가능.
  - 두 프로세스가 공유 우편함을 가질 때만 통신할 수 있음.
- 메세지에 있어 유연성을 제공함.
- 성질
  - 공유 우편함이 있는 경우에만 프로세스 쌍 사이에 링크가 설정됨
  - 한 링크는 2개 이상의 프로세스들과 연관될 수 있음.
  - 각 통신 프로세스 쌍 사이에는 몇 개의 다른 링크가 있을 수 있으며, 각각은 서로 다른 우편함과 교신함.
  - 링크는 단방향이거나 양방향일 수 있음
- 프로세스 vs 운영체제
  - 우편함이 프로세스에 소속될 경우
    - 소유자를 구별함.
    - 수신에 대한 혼동이 없으며, 프로세스가 종료되면 우편함도 사라짐.
      - 예외처리를 통하여 우편함이 존재하지 않는다는 것을 알려야 함.
  - 우편함이 운영체제에 소속될 경우
    - 스스로 존재하며 독립적임
    - 소유권과 수신권이 시스템 호출에 의해 다른 프로세스에 넘겨질 수 있음

### 4.2.3. 링크의 용량

- '0'의 용량 - 용량이 없는 경우
  - 링크 자체에 보관 능력이 없음
  - 버퍼가 없기 때문에 큐도 없음
  - 동기화가 필요함
- 제한된 용량
  - 크기 n 만큼의 큐가 생성될 수 있음
- 무제한 용량
  - 큐의 크기가 무제한이다

제한된 용량, 무제한 용량은 자동으로 버퍼링이 적용됨.



### 4.2.4. 예외조건







