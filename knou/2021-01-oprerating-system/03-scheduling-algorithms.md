# 1. 스케줄링 성능 평가 기준

## 1.1. 평균 대기시간 & 평균 반환시간

- 대기시간: 프로세스가 준비 큐에서 기다리는 시간의 합.
- 반환시간: 프로세스가 생성되어 준비큐에 들어와 프로세스가 종료되는 순간까지의 시간의 합.


- 평균 대기시간: 각 프로세스가 수행이 완료될 때까지 준비 큐에서 기다리는 시간의 합의 평균값
	- (대기시간a + 대기시간b) / 프로세스개수 
- 평균 반환시간: 각 프로세스가 생성된 시점부터 수행이 완료된 시점까지 소요시간의 평균값
	- (반환시간a + 반환시간b) / 프로세스개수


# 2. 다양한 스케줄링 알고리즘

- FCFS
- SJF
- SRT
- RR
- HRN
- 다단계 피드백 큐


## 2.1. FCFS 스케줄링

First-come-first-serve 스케줄링

- 비선점 스케줄링 알고리즘 (일단 CPU를 할당하면, 프로세스가 끝날 때까지 다른 프로세스에 CPU를 할당하지 않음)
- 준비 큐에 도착한 순서에 따라 디스패치

### 2.1.1. 대기시간 및 반환시간

**프로세스**

| 프로세스 | A  | B  | C  | D  |
|----------------|---|---|---|---|
| 도착시간   | 0 | 0 | 0  | 0  |
| CPU사이클    | 6  | 3  | 1  | 4  |


**대기시간 및 반환시간**

| 프로세스 | A  | B  | C  | D  |
|----------------|---|---|---|---|
| 대기시간   | 0 | 6 | 9  | 10  |
| 반환시간  | 6  | 9  | 10  | 14  |

- 평균대기시간: 25 / 4 = 6.25
- 평균반환시간: 39 / 4 = 9.75

### 2.1.2. 장단점

- 장점
	- 가장 간단한 스케줄링 기법
- 단점
	- 짧은 프로세스가 긴 프로세스를 기다리거나, 중요한 프로세스가 나중에 수행될 수 있음.
	- 프로세스들의 도착 순서에 따라 평균 반환시간이 크게 달라질 수 있음.

## 2.2. SJF 스케줄링

Shortest Job First

- 비선점 스케줄링 알고리즘
- 준비 큐에서 기다리는 프로세스 중 실행시간이 가장 짧다고 예상된 것을 먼저 디스패치

### 2.2.1. 대기시간 및 반환시간 (1)

**프로세스**

| 프로세스 | A  | B  | C  | D  |
|----------------|---|---|---|---|
| 도착시간   | 0 | 0 | 0  | 0  |
| CPU사이클    | 6  | 3  | 1  | 4  |

**대기시간 및 반환시간**

| 프로세스 | C  | B  | D  | A  |
|----------------|---|---|---|---|
| 대기시간   | 0 | 1 | 4  | 8  |
| 반환시간  | 1  | 4  | 8  | 14  |

- 평균대기시간: 13 / 4 = 3.25
- 평균반환시간: 27 / 4 = 6.75

### 2.2.2. 대기시간 및 반환시간 (1)

(도착시간이 달라질 경우)

**프로세스**

| 프로세스 | A  | B  | C  | D  |
|----------------|---|---|---|---|
| 도착시간   | 0 | 1 | 2  | 3  |
| CPU사이클    | 6  | 3  | 1  | 4  |

**대기시간 및 반환시간**

| 프로세스 | A  | C  | B  | D  |
|----------------|---|---|---|---|
| 대기시간   | 0 | 4 | 6  | 7  |
| 반환시간  | 6  | 5  | 9  | 11  |

- 평균대기시간: 17 / 4 = 4.25
- 평균반환시간: 31 / 4 = 7.75


### 2.2.3. 장단점

- 장점
	- 일괄처리 환경에서 구현하기 쉬움
	- 짧게 끝날 프로세스를 앞에 배치할 수 있음.
- 단점
	- 실행 예정 시간 길이를 사용자의 추정치에 의존함.
	- 따라서 실제로 먼저 처리할 작업의 CPU 시간을 예정하기가 거의 불가능함.


## 2.3. SRT 알고리즘

Shortest Remaining Time

- 선점 스케줄링 알고리즘
- 실행이 끝날 때까지 남은 시간 추정치가 가장 짧은 프로세스를 먼저 디스패치

### 2.3.1. 대기시간 및 반환시간

**프로세스**

| 프로세스 | A  | B  | C  | D  |
|----------------|---|---|---|---|
| 도착시간   | 0 | 1 | 2  | 3  |
| CPU사이클    | 6  | 3  | 1  | 4  |

**실행순서**

A(1) -> B(1)  -> C(1) -> B(2) -> D(4) -> A(5)

**대기시간 및 반환시간**

| 프로세스 | A  | B  | C  | D  |
|---------|---|---|---|---|
| 대기시간   | 8 | 1 | 0  | 2  |
| 반환시간  | 14  | 4  | 1  | 6  |

- 평균대기시간: 11 / 4 = 2.75
- 평균반환시간: 25 / 4 = 6.25

### 2.3.2. 장단점

- 장점
	- SJF보다 평균 대기시간이나 평균 반환시간에서 효율적
	- 대화형 운영체제에 유용
- 단점
	- 각 프로세스의 실행시간 추적, 선점을 위한 문맥 교환 등 SJF보다 오버헤드가 큼


## 2.4. RR 알고리즘

Round Robin

- 선점 스케줄링 알고리즘
- 준비 큐에 도착한 순서에 따라 디스패치하지만 (FCFS)
	- 정해진 시간 할당량에 의해 실행을 제한함
- 시간 할당량 안에 완료되지 못한 프로세스는 준비 큐의 맨 뒤에 배치함

### 2.4.1. 대기시간 및 반환시간

**프로세스 (시간 할당량 = 3)**

| 프로세스 | A  | B  | C  | D  |
|----------------|---|---|---|---|
| 도착시간   | 0 | 1 | 2  | 3  |
| CPU사이클    | 6  | 3  | 1  | 4  |

**실행순서**

A(3) -> B(3)  -> C(1) -> B(2) -> D(3) -> A(3) -> D(1)

**대기시간 및 반환시간**

| 프로세스 | A  | B  | C  | D  |
|---------|---|---|---|---|
| 대기시간   | 7 | 2 | 4  | 7  |
| 반환시간  | 13  | 5  | 5  | 11  |

- 평균대기시간: 11 / 4 = 2.75
- 평균반환시간: 25 / 4 = 6.25

### 2.4.2. 장단점

- 장점
	- CPU를 독점하지 않고 공평하게 이용
	- 대화형 운영체제에 유용함 (사용자에게 빠르게 응답)
- 단점
	- 시간 할당량이 너무 크면, FCFS 스케줄링과 같아짐
	- 시간 할당량이 너무 작으면 문맥 교환에 따른 오버헤드가 크게 증가함
	
	
## 2.5. HRN 알고리즘

Highest Response Ratio Next (or HRRN)

- 비선점 스케줄링 알고리즘
- 준비 큐에서 기다리는 프로세스 중 응답비율이 가장 큰 것을 먼저 디스패치

> 응답비율 = (대기시간 + 예상실행시간) / 예상실행시간 = (대기시간/예상실행시간) + 1
> 
> - 예상 실행시간이 짧을 수록, 대기시간이 길 수록 응답비율이 커짐


### 2.4.1. 대기시간 및 반환시간

**프로세스 (시간 할당량 = 3)**

| 프로세스 | A  | B  | C  | D  |
|-----------|---|---|---|---|
| 도착시간   | 0 | 1 | 4  | 6  |
| CPU사이클    | 6  | 3  | 2  | 1  |

**실행순서**

A -> B -> D -> C

**대기시간 및 반환시간**

| 프로세스 | A  | B  | C  | D  |
|---------|---|---|---|---|
| 대기시간   | 0 | 5 | 6  | 3  |
| 반환시간  | 6  | 8  | 8  | 4  |

- 평균대기시간: 14 / 4 = 3.5
- 평균반환시간: 26 / 4 = 6.5

### 2.4.2. 장단점

- 장점
	- SJF의 단점을 보완
	- 하염없이 기다리는게 아니라, 응답비율에 따라 적절한 시점에 실행될 수 있음

	
## 2.6. 다단계 피드백 큐 스케줄링

- 선점 스케줄링 알고리즘
- I/O 중심 프로세스와 CPU 중심 프로세스의 특성에 따라 서로 다른 시간 할당량 부여
- n개의 단계
	- 단계 1 ~ 단계 n
	- 각 단계마다 하나씩의 큐 존재
	- 단계가 커질 수록 시간 할당량도 커짐

### 2.6.1. 스케줄링 방법

- 신규 프로세스는 단계1의 큐에서 FIFO 순서에 따라 CPU를 점유
- 입출력 같은 이벤트가 발생하면 CPU를 양보하고 대기상태로 감
	- 다시 준비상태가 될 때에는 현재와 동일한 단계의 큐에 배치함.
- 시간 할당량을 다 썼지만 프로세스가 종료되지 못했다면 다음 단계의 큐로 이동 배치
- 마지막 단계 n에서는 RR스케줄링 방식으로 동작
- 단계 k의 큐에 있는 프로세스가 CPU를 할당 받으려면 단계1 부터 단계 k-1까지 모든 큐가 비어있어야 함

### 2.6.2. 장단점

- I/O 위주의 프로세스(대화형)는 높은 우선권 유지
- 연산 위주의 CPU중심 프로세스는 낮은 우선권이지만 긴 시간 할당량을 가짐

**적응적 다단계 피드백 큐 스케줄링**

- 시간 할당량을 다 쓰기 전에 CPU를 반납하는 경우 하나 작은 단계의 큐로 이동배치함.
- 연산 위주의 프로세스가 I/O위주로 바뀐다면 점점 작은 단계로 배치 가능



# 3. 스케줄링 알고리즘 정리

개선 및 발전의 흐름
	
- FCFS -> RR -> 다단계 피드백 큐
- SJF -> HRN -> SRT

